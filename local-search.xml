<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo</title>
    <link href="/pumpkin/2022/05/20/Tools/Hexo/"/>
    <url>/pumpkin/2022/05/20/Tools/Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>Node.js</li><li>Git</li></ul><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="启动本地项目"><a href="#启动本地项目" class="headerlink" title="启动本地项目"></a>启动本地项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 初始化Hexo项目</span><br>hexo init demo<br><span class="hljs-built_in">cd</span> demo<br>npm install<br><span class="hljs-comment"># 启动本地Hexo项目</span><br>hexo server<br></code></pre></td></tr></table></figure><h3 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h3><ol><li>在Github上创建仓库 demo</li><li>安装插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ol start="3"><li>修改配置文件<code>_config.yml</code> 配置远程部署仓库</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/rongkezan/demo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><ol start="4"><li>修改配置文件<code>_config.yml</code> 配置根目录</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://rongkezan.github.io/demo</span><br></code></pre></td></tr></table></figure><ol start="5"><li>部署</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo deploy<br></code></pre></td></tr></table></figure><h2 id="Hexo-主题-–-Fluid"><a href="#Hexo-主题-–-Fluid" class="headerlink" title="Hexo 主题 – Fluid"></a>Hexo 主题 – Fluid</h2><ol><li><p>Fluid官方文档：<a href="https://hexo.fluid-dev.com/docs">https://hexo.fluid-dev.com/docs</a></p></li><li><p>拉取Fluid主题</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><ol start="3"><li>修改配置文件<code>_config.yml</code> 主题配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建关于页</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new page about<br></code></pre></td></tr></table></figure><ol start="5"><li>覆盖配置</li></ol><p>复制官方配置文件到博客目录下： <code>_config.fluid.yml</code></p><p>官方配置文件：<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合</title>
    <link href="/pumpkin/2022/05/20/Java/Java%E9%9B%86%E5%90%88/"/>
    <url>/pumpkin/2022/05/20/Java/Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote><p>ArrayList、LinkedList、Vector、Stack、CopyOnWriteArrayList</p></blockquote><table><thead><tr><th>名称</th><th>特点</th><th>get(index)</th><th>add(E)</th><th>add(index, E)</th><th>remove(E)</th></tr></thead><tbody><tr><td>ArrayList</td><td>高效，线程不安全</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>LinkedList</td><td>删除更高效，查询低效</td><td>O(n)</td><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>Vector</td><td>低效，线程安全</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ol><li>底层是数组</li><li>默认装Object</li><li>初始为10，(Jdk8之后默认添加数据的时候才开始给默认长度)。</li><li>每次扩容是原长度的一半（取整）：第一次扩到15，第二次22</li><li>扩容方式：Arrays.copyOf，默认把原数组复制到新数组</li><li>不是线程安全的</li></ol><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ol><li>底层是双向链表</li><li>链表删除和增加快，查询和修改慢</li><li>实现了Queue接口，所以还提供了offer(), peek(), poll()等方法</li></ol><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>写时加锁，读时不加锁，复制一个新的数组，把新数组指向原来的数组</p><p>适用于读多写少的场景</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote><p>LinkedHashSet、TreeSet、EnumSet、CopyOnWriteArraySet、ConcurrentSkipListSet</p></blockquote><table><thead><tr><th>名称</th><th>特点</th><th>add(E)</th><th>remove(E)</th><th>contains(E)</th></tr></thead><tbody><tr><td>HashSet</td><td>线程不安全，可存储null值</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>LinkedHashSet</td><td>查询时有序 (存储还是无序)</td><td>O(logn)</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>TreeSet</td><td>可根据指定值排序(基于红黑树)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ol><li>底层是HashMap</li><li>添加过程</li></ol><p><img src="https://img-blog.csdnimg.cn/20200209154216578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>在多线程的情况下，多考虑使用Queue</p><h4 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque 双端队列"></a>Deque 双端队列</h4><blockquote><p>ArrayDeque、BlockingDeque、LinkedBlockingDeque</p></blockquote><h4 id="BlokingQueue"><a href="#BlokingQueue" class="headerlink" title="BlokingQueue"></a>BlokingQueue</h4><blockquote><p>ArrayBlockingQueue、ProrityBlockingQueue、LinkedBlockingQueue</p></blockquote><p>获取数据时队列中无数据，阻塞。添加数据时队列已满，阻塞。</p><p><strong>添加元素</strong></p><p>add：添加元素的时候，若超出了度列的长度会直接抛出异常</p><p>offer：添加元素的时候，若超出了度列的长度会直接返回false</p><p>put：添加元素的时候，若超出了度列的长度会阻塞一直等待空间，以加入元素</p><p><strong>获取元素</strong></p><p>remove：获取元素，若队列为空，会抛出异常</p><p>poll：获取元素，队列为空时，返回null</p><p>take：获取元素，队列为空时，队列阻塞</p><p>element：查看队首元素，队列元素为空抛异常</p><p>peek：查看队首元素，队列元素为空返回 null</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>容量为0的队列，使用put添加元素时阻塞，直到另一个线程取到数据</p><p>场景：两个线程交换数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>            System.out.println(<span class="hljs-string">&quot;子线程取到主线程数据:&quot;</span> + value);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;).start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    blockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TransferQueue-LinkedTransferQueue"><a href="#TransferQueue-LinkedTransferQueue" class="headerlink" title="TransferQueue LinkedTransferQueue"></a>TransferQueue LinkedTransferQueue</h5><p>与 SynchronousQueue 的区别在于，使用 <code>transfer</code> 方法来添加数据，并且当这个数据不被取走，线程会一直守在原地，类似MQ的消息确认机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">transferQueue.transfer(<span class="hljs-string">&quot;data&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><blockquote><p>底层使用CAS实现原子性操作</p></blockquote><p>使用 ConcurrentLinkedQueue 实现卖票程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Queue&lt;String&gt; tickets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>        tickets.add(<span class="hljs-string">&quot;票 编号:&quot;</span> + i);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> tickets.poll();<br>                <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>                System.out.println(<span class="hljs-string">&quot;销售了 - &quot;</span> + s);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>有序的队列，内部使用二叉树实现</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>按照内部到期的时间进行排序，等待时间短的会排到队列的前面。</p><p>使用场景：按时间进行任务调度</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><table><thead><tr><th>名称</th><th>特点</th><th>get(key)</th><th>put(key)</th></tr></thead><tbody><tr><td>HashMap</td><td>线程不安全，高效</td><td>O(1)~O(log n)</td><td>O(1)</td></tr><tr><td>LinkedHashMap</td><td>查询时有序 (存储还是无序)</td><td>O(1)~O(log n)</td><td>O(1)</td></tr><tr><td>TreeMap</td><td>可根据指定值排序(取决于Compare返回值)</td><td>O(log n)</td><td>O(1)</td></tr><tr><td>Hashtable</td><td>线程安全，低效</td><td>O(1)~O(log n)</td><td>O(1)</td></tr></tbody></table><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>JDK7和8的异同</strong></p><p>JDK7：</p><ol><li>数组 + 链表</li><li>插入链表头部</li><li>直接计算 key 的 HashCode 值</li><li>扩容时会颠倒链表顺序</li><li>只要大于阈值就直接扩容2倍</li></ol><p>JDK8：</p><ol><li>数组 + 链表 + 红黑树</li><li>插入链表尾部</li><li>采用 Key 的 HashCode 异或上 Key 的 HashCode 进行无符号右移16位的结果 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，避免了只靠低位数据来计算哈希时导致的冲突，计算结果由高低位结合决定，使元素分布更均匀</li><li>扩容时保持原链表顺序</li><li>当数组容量小于64时，直接扩容。大于64时，若链表长度大于8就转红黑树，否则就扩容。</li></ol><p><strong>负载因子为什么是0.75</strong></p><p>负载因子过小会导致更快扩容，浪费空间。过大会导致哈希碰撞的几率变大。</p><p><strong>HashMap扩容复制</strong></p><p>不是简单的将原数组中的每一个元素取出进行重新hash映射，而是做移位检测。所谓移位检测的含义具体是针对HashMap做映射时的&amp;运算所提出的，通过上文对&amp;元算的分析可知，映射的本质即看hash值的某一位是0还是1，当扩容以后，会相比于原数组多出一位做比较，由多出来的这一位是0还是1来决定是否进行移位，而具体的移位距离，也是可知的。</p><p><strong>JDK8添加过程</strong></p><ol><li>底层：数组 + 链表 + 红黑树</li><li>首次添加操作创建数组，长度16，存的是一维数组Entry[]</li><li>扩容：超过临界值(Capacity * Load Factory)，则扩容为原来2倍，并将元数据复制过来<br><img src="https://img-blog.csdnimg.cn/20200209154206861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>有序基于链表实现的 HashMap</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>基于红黑树实现的有序Map</p><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 自定义排序规则<br>new TreeMap&lt;String, String&gt;(new Comparator<String>() {<br>  @Override<br>  public int compare(String o1, String o2) {<br>    return 0;<br>  }<br>});</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.7：Segment + HashEntry + Unsafe</p><p>1.8：移除Segment，使锁的粒度更小，Synchronized + CAS</p><h3 id="ConcurrentSkitListMap"><a href="#ConcurrentSkitListMap" class="headerlink" title="ConcurrentSkitListMap"></a>ConcurrentSkitListMap</h3><blockquote><p>同步容器，有序</p></blockquote><p><strong>跳表</strong></p><p>算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。</p><p><img src="https://img-blog.csdnimg.cn/20210115222639601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>Entry 是弱引用，如果没有被其他强引用，那么GC后就会被回收</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 锁</title>
    <link href="/pumpkin/2022/05/20/Java/Java%E9%94%81/"/>
    <url>/pumpkin/2022/05/20/Java/Java%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h1><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM (Java Memory Model)"></a>JMM (Java Memory Model)</h2><p>是一组规范，可见性、原子性、有序性，定义了程序中各个变量的访问方式。</p><p><strong>解释</strong>：线程创建时JVM会为其创建工作内存（线程私有），JMM规定所有变量存储在主内存（共享），但线程必须在工作内存中操作变量。具体流程：拷贝-&gt;操作-&gt;写回&lt;&#x2F;。各个工作内存存储主内存变量的复印件，不同线程无法互相访问，线程间通信必须通过主内存。</p><p><img src="https://img-blog.csdnimg.cn/20210121135743932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>JMM关于同步的规定</strong>：</p><ol><li>线程解锁前，必须把共享变量的值刷新回主内存。</li><li>线程加锁前，必须读取主内存的最新值到工作内存。</li><li>加锁解锁是同一把锁。</li></ol><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>保证可见性，禁止指令重排</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>缓存一致性协议。JMM模型里有8个指令完成数据的读写，通过其中load和store指令相互组成的4个内存屏障实现禁止指令重排序。</p><p><strong>字节码层面</strong>：ACC_VOLATILE</p><p><strong>JVM层面</strong></p><p><img src="https://img-blog.csdnimg.cn/20210117102410887.png" alt="在这里插入图片描述"></p><p><strong>JVM内存屏障</strong></p><p>LoadLoad：在Load2及后续读取操作的数据被访问前，保证Load1要读取的数据读取完毕。</p><p>StoreStore：在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p><p>LoadStore：在Store2及后续写入操作刷出前，保证Load1要读取的数据被读取完毕。</p><p>StoreLoad：在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</p><p><strong>OS层面：硬件内存屏障、原子指令</strong></p><p>sfence：save | 在sfence指令前的写操作必须在sfence指令后的写操作前完成</p><p>lfence：load | 在lfence指令前的读操作必须在lfence指令后的读操作前完成</p><p>mfence：modify&#x2F;mix | 在mfence指令前的读写操作必须在mfence指令后的读写操作前完成</p><p>原子指令：如x86上的lock前缀指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序</p><p><strong>为什么volatile不能实现原子性</strong></p><p>没有原子性是因为底层代码一个++操作会被写成多行c++，这时候失去CPU分片就会值被改掉</p><p><strong>单例模式中的DCL为什么要加volatile</strong></p><p>由于指令重排，对象在半初始化状态的时候就赋值给这个变量了，即instance已经不再是null，第二个线程就直接拿来使用这个半初始化状态的对象。</p><p><strong>volatile引用对象</strong></p><p>如果volatile修饰的是一个引用对象，那么引用对象内部的属性发生改变volatile是无法观察到的。</p><h2 id="CAS-Compare-And-Set"><a href="#CAS-Compare-And-Set" class="headerlink" title="CAS (Compare And Set)"></a>CAS (Compare And Set)</h2><p><strong>作用</strong>：线程的期望值和物理内存真实值一样则修改，否则需要重新获得主物理内存的真实值，这个过程是原子的。</p><p><strong>原理</strong>：Unsafe、自旋锁、乐观锁</p><ul><li><p>Unsafe：Java无法直接访问底层系统，可以基于Unsafe内部native方法可以像C的指针一样直接操作内存。</p></li><li><p>自旋锁：循环判断工作内存与主内存的值是否相等，如相等则返回。</p></li></ul><p><strong>缺点</strong>：循环时间长开销大、只能保证一个共享变量的原子操作、ABA问题。</p><p><strong>CAS是怎么保证原子性的</strong></p><p>获取内存中的值，CAS比较不一致，则继续获取内存中的值，直到CAS成功为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// var1: 当前对象</span><br><span class="hljs-comment">// var2: 当前对象的内存偏移量地址</span><br><span class="hljs-comment">// var4: 增加的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 根据当前对象的内存偏移量获取当前对象的值</span><br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    <span class="hljs-comment">// 如果CAS比较结果不一致，则继续循环，否则退出循环</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么CAS要比synchronized快</strong></p><p>synchronized需要进行上下文切换，每一次线程进出Cpu就是一次上下文切换，而这一次切换大概需要3-5微秒，而Cpu执行一条执行大概只需要0.6纳秒，而CAS没有上下文切换的过程，那么效率就高。</p><p><strong>ABA问题</strong></p><p>CAS只会判断最终的对象是否与期望的一致，但不会判断在这期间对象是否有改变，当这期间对象发生了改变，就会产生ABA问题，即虽然判断对象是同一个，但是其中的属性发生了改变。</p><p>解决方案：加版本号。</p><p><strong>并发累加Long的三种方式</strong></p><ol><li>加锁</li><li>AtomicLong：CAS</li><li>LongAdder：分段锁，线程数量特别多的时候比Atomic更有优势</li></ol><p><strong>AtomicInteger</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data:&quot;</span> + atomicInteger.get());<br>System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data:&quot;</span> + atomicInteger.get());<br>atomicInteger.getAndIncrement();<br></code></pre></td></tr></table></figure><p><strong>AtomicReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">z3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">l4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;l4&quot;</span>, <span class="hljs-number">25</span>);<br><br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>        atomicReference.set(z3);<br>        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get().toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@ToString</span><br>    <span class="hljs-meta">@AllArgsConstructor</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>        String username;<br>        <span class="hljs-type">int</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="按性质分类"><a href="#按性质分类" class="headerlink" title="按性质分类"></a>按性质分类</h3><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁。</p><p><strong>非公平锁</strong>：多个线程获取锁的顺序并不是按照申请锁的顺序。</p><p><strong>乐观锁</strong>：采用尝试更新，不断重新的方式更新数据。</p><p><strong>悲观锁</strong>：对于同一个数据的并发操作，悲观锁采取加锁的形式。</p><p><strong>独享锁</strong>：该锁一次只能被一个线程所持有。</p><p><strong>共享锁</strong>：该锁可被多个线程所持有。</p><p><strong>互斥锁</strong>：写锁。</p><p><strong>读写锁</strong>：可以多人读，但只允许一人写。</p><p><strong>可重入锁</strong>：在同一个线程的外层方法获取锁的时候，进入内层方法会自动获取锁。避免死锁。</p><p><strong>对象锁</strong>：将sychronized放在普通同步方法中，sychronized同步监视器为普通对象</p><p><strong>全局锁</strong>：将sychronized放在静态同步方法中，sychronized同步监视器为类对象</p><h3 id="按照设计分类"><a href="#按照设计分类" class="headerlink" title="按照设计分类"></a>按照设计分类</h3><p><strong>自旋锁</strong>：采用循环的方式去尝试获取锁。</p><p><strong>自适应自旋锁</strong>：循环多次发现等待时间过长，切换为阻塞状态。</p><p><strong>锁粗化</strong>：如一个方法内加了多个锁，JVM认为没必要，于是将其合并为一个锁。</p><p><strong>锁消除</strong>：JVM认为有些代码块无需加锁，于是删除了那个锁。</p><p><strong>偏向锁</strong>：一段同步代码一直被一个线程访问，该线程会自动获得锁。</p><p><strong>轻量级锁</strong>：当锁是偏向锁的时候，被另外线程访问，其它线程会通过自旋的形式尝试获取锁。</p><p><strong>重量级锁</strong>：当锁是轻量级锁的时候，另一个线程自旋到一定次数未得到锁则进入阻塞。</p><p><strong>分段锁</strong>：将数据分为多段，每次只给一段加锁。</p><h2 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h2><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><ol><li>无锁：程序不会有锁竞争</li><li>偏向锁：经常只有一个线程加锁，markword 记录线程ID</li><li>自旋锁：有线程来参与锁的竞争，但是获取锁的冲突时间很短</li><li>重量级锁：自旋10次以后，升为重量级锁 - 去OS申请锁资源</li></ol><p>什么时候用自旋什么时候用重量级锁？</p><p>执行时间长，线程多用重量级锁，否则用自旋。</p><h3 id="锁发生改变"><a href="#锁发生改变" class="headerlink" title="锁发生改变"></a>锁发生改变</h3><ol><li><p>程序中如果出现异常，默认情况下锁会被释放</p></li><li><p>如果锁对象发生改变，锁就会失效。</p><p>解决方案： 锁对象加 <code>final</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br></code></pre></td></tr></table></figure><h2 id="JUC和同步锁锁"><a href="#JUC和同步锁锁" class="headerlink" title="JUC和同步锁锁"></a>JUC和同步锁锁</h2><h3 id="Syncronized-实现细节"><a href="#Syncronized-实现细节" class="headerlink" title="Syncronized 实现细节"></a>Syncronized 实现细节</h3><p>字节码层面：monitorenter monitorexit</p><p>JVM层面：C  C++ 调用了操作系统提供的同步机制</p><p>OS和硬件层面：x86是 <code>lock comxchg xxx</code>，lock是用来锁其它指令的</p><h3 id="Sychronized-and-Lock"><a href="#Sychronized-and-Lock" class="headerlink" title="Sychronized and Lock"></a>Sychronized and Lock</h3><ol><li>Sychronized：非公平，悲观，独享，互斥，可重入的重量级</li><li>Lock<ol><li>ReentrantLock：可公平，悲观，独享，互斥，可重入，重量级锁。</li><li>ReentrantReadWriteLock：可公平，悲观，写独享，读共享，读写，可重入，重量级锁。</li></ol></li></ol><p><strong>Sychronized 和 ReentrantLock 的区别</strong></p><ol><li>synchronized是关键字，Lock是Api</li><li>synchronized自动释放锁，Lock手动释放</li><li>synchronized不可以中断，ReentrantLock可中断(调用interrupt方法)</li><li>synchronized非公平锁，Lock两者皆可</li><li>synchronized只能随机或全部唤醒，Lock可以使用Condition精确唤醒</li></ol><p><strong>Sychronized 和 ReentrantLock 的使用场景</strong></p><p>sychronized如果抢不到锁，就会一直等待</p><p>reentrantLock有tryLock机制，如果等待超时可以放弃等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">3L</span>, TimeUnit.SECONDS))&#123;<span class="hljs-comment">// 3秒超时</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 放弃等待后执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReadWriteLock-StampedLock"><a href="#ReadWriteLock-StampedLock" class="headerlink" title="ReadWriteLock - StampedLock"></a>ReadWriteLock - StampedLock</h3><p>ReadLock：读锁，读的时候其它读线程依然可以进入</p><p>WriteLock，写锁，写的时候不允许其它线程进入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>被减少到零之后才放行，否则阻塞等待。</p><p>定义一个CountDownLatch，有初始值，使用await阻塞线程，当减少到0时消除阻塞，类似于join但是更灵活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        countDownLatch.countDown();<br>    &#125;, String.valueOf(i)).start();<br>&#125;<br>countDownLatch.await();<br>System.out.println(<span class="hljs-string">&quot;解除门栓&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>先到的被阻塞，直到达到指定值时释放</p><p>await到指定个线程之后，放行</p><p>场景：某线程需等待其它线程执行完后才能执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">7</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;释放通行&quot;</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++)&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">tempInt</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程已到&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            cyclicBarrier.await();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, String.valueOf(i)).start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>CyclicBarrier升级版，使用arriveAndAwaitAdvance到达一个阶段的时候等待其它线程完成再向后执行</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>多共享资源的互斥使用，并发线程数的控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在多个线程并发访问时，最多只有3个线程可以同时运行</span><br><span class="hljs-comment">// acquire:总量-1</span><br><span class="hljs-comment">// release:总量+1</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        semaphore.release();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>两个线程间交换数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行exchange()时阻塞线程</span><br>Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    exchanger.exchange(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    exchanger.exchange(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="线程等待和唤醒"><a href="#线程等待和唤醒" class="headerlink" title="线程等待和唤醒"></a>线程等待和唤醒</h2><h3 id="Object-wait-notify"><a href="#Object-wait-notify" class="headerlink" title="Object: wait, notify"></a>Object: wait, notify</h3><ol><li>都需要在同步代码块中执行(synchronized)</li><li>先wait再notify，等待中的线程才会被唤醒，否则无法唤醒</li><li>notify是随机唤醒一个线程</li><li>notify不释放锁，需要等待线程执行完或者线程中wait()才释放</li><li>notifyAll将所有线程唤醒，去争抢锁，但抢到锁的依旧只有一个线程</li></ol><h3 id="Condition-await-signal"><a href="#Condition-await-signal" class="headerlink" title="Condition: await, signal"></a>Condition: await, signal</h3><ol><li>都需要在同步代码块中执行</li><li>先await再signal，等待中的线程才会被唤醒，否则无法唤醒</li><li>可以精确的指定哪些线程被唤醒，即使用不同的condition加锁即可，condition的本质就是不同的等待队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Condition</span> <span class="hljs-variable">condition1</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition2</span> <span class="hljs-operator">=</span> lock.newCondition();<br></code></pre></td></tr></table></figure><h3 id="LockSupport-pack-unpack"><a href="#LockSupport-pack-unpack" class="headerlink" title="LockSupport: pack, unpack"></a>LockSupport: pack, unpack</h3><p>线程阻塞工具类，可以让线程在任意位置阻塞，阻塞后也有对应的唤醒方法，底层调用Unsafe的native方法</p><p>线程阻塞需要消耗Permit，Permit最多存在1个</p><p>当调用park方法时</p><ul><li>如果有凭证，直接消耗掉这个凭证然后正常退出</li><li>如果无凭证，就阻塞等待凭证可用</li></ul><p>当调用unpark方法时</p><ul><li>增加一个凭证，但凭证最多有1个</li></ul><h2 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS (AbstractQueuedSynchronizer)"></a>AQS (AbstractQueuedSynchronizer)</h2><p>概念：是用来构建锁或者其它同步组件的抽象父类</p><p><strong>CAS + volatile state + 双端队列</strong></p><p>CAS：在往队列末端加线程的时候使用的是CAS</p><p>volatile：state变量用volatile修饰保证线程之间可见</p><p>state：根据子类的具体实现来分配，如ReentrantLock加锁,是1，不加锁是0；CountDownLatch设置为5，state就是5</p><p>双端队列：CLH变种的双端队列，Node中存放的是线程</p><p><strong>公平锁和非公平锁</strong></p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了，非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 公平锁会通过 hasQueuedPredecessors 方法判断队列前是否有元素 有就排队 */</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 非公平锁上来直接就抢锁 */</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201218203120948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>源码说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<span class="hljs-comment">// 第一个线程抢到锁</span><br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<span class="hljs-comment">// 第二个线程及后续线程抢占</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<span class="hljs-comment">// 尝试抢占，抢占成功返回true不进入队列</span><br>        <span class="hljs-comment">// acquireQueued 尝试获取锁，若不成功则用LockSupport.park阻塞，直到被唤醒</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 第二次以后进入只需将Node加入队列末尾即可</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 第一次进入队列会先初始化，即生成一个空的头节点</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果前置节点是头节点，那么第二个节点会尝试获得锁</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg))&#123;&#125;<br></code></pre></td></tr></table></figure><p>JDK9使用VarHandle：普通的原子操作，比反射快，直接操作二进制码</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><blockquote><p>线程独享的Map</p></blockquote><p><strong>ThreadLocalMap中的Entry是弱引用</strong></p><ol><li>若是强引用，即使tl &#x3D;&#x3D; null，但key的引用依然指向ThreadLocal对象，所以有内存泄露，而使用弱引用则不会。</li><li>但还是有内存泄露的存在，ThreadLocalMap 是 Thread 的一个属性，生命周期跟 Thread 一致，当ThreadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄露。所以ThreadLocal不用了需要调用 <code>remove()</code>回收</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;M&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>tl.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">M</span>());<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210114221056228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程</title>
    <link href="/pumpkin/2022/05/20/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/pumpkin/2022/05/20/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h2 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1. 线程的概念"></a>1. 线程的概念</h2><p><strong>操作系统是如何切换线程的</strong></p><p>Cpu会从内存里取出线程，线程内部状态是由线程栈来维护的。</p><p>一个程序的不同分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 顺序执行</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">T1</span>().run();<br><span class="hljs-comment">// 并行执行</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">T1</span>().start();<br><span class="hljs-comment">// 睡眠500毫秒</span><br>Thead.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-comment">// 让出线程,使线程进入等待队列，但也有可能再次被Cpu拿出来执行</span><br>Thread.yield();<br><span class="hljs-comment">// t2运行中调用t1.join()即执行t1线程，保证t1结束以后t2才能继续运行</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;t1&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123; t1.join(); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br></code></pre></td></tr></table></figure><p>线程状态迁移图</p><p><img src="https://img-blog.csdnimg.cn/20210107211056470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-线程的创建方式"><a href="#2-线程的创建方式" class="headerlink" title="2. 线程的创建方式"></a>2. 线程的创建方式</h2><ol><li>继承Thead类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 运行了...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// main</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>t.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>实现Runnable接口</li></ol><p>普通写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 运行了...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// main</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t).start();<br></code></pre></td></tr></table></figure><p>lambda写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 运行了...&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure><ol start="3"><li>实现Callable接口：可以抛出异常，支持泛型的返回值</li></ol><ul><li>Future：可以获得线程的执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>System.out.println(<span class="hljs-string">&quot;结果:&quot;</span> + result);<br></code></pre></td></tr></table></figure><ul><li><p>CompletableFuture</p><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><p><code>CompletableFuture</code>更强大的功能是，多个<code>CompletableFuture</code>可以串行执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建异步执行任务</span><br>CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">1</span>);<br>CompletableFuture&lt;Integer&gt; task2 = task1.thenApplyAsync(o -&gt; o + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 如果执行成功</span><br>task2.thenAccept(res -&gt; System.out.println(<span class="hljs-string">&quot;最终结果:&quot;</span> + res));<br><span class="hljs-comment">// 如果执行异常</span><br>task2.exceptionally(e -&gt; &#123;<br>  System.out.println(<span class="hljs-string">&quot;Failed: &quot;</span> + e.getMessage());<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;);<br><span class="hljs-comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭</span><br>Thread.sleep(<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>使用线程池</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br>ScheduledFuture&lt;Integer&gt; result = pool.schedule(() -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">100</span>);<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + num);<br>    <span class="hljs-keyword">return</span> num;<br>&#125;, <span class="hljs-number">100</span>, TimeUnit.MILLISECONDS);<br>System.out.println(result.get());<br>pool.shutdown();<br></code></pre></td></tr></table></figure><h2 id="3-线程池详解"><a href="#3-线程池详解" class="headerlink" title="3. 线程池详解"></a>3. 线程池详解</h2><h3 id="3-1-线程池种类"><a href="#3-1-线程池种类" class="headerlink" title="3.1 线程池种类"></a>3.1 线程池种类</h3><ul><li>newFixedThreadPool（固定大小的线程池）</li><li>newSingleThreadExecutor（单线程线程池）</li><li>newCachedThreadPool（可缓存线程的线程池）用于并发执行大量短期的小任务。</li><li>newScheduledThreadPool：用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</li></ul><h3 id="3-2-线程池参数"><a href="#3-2-线程池参数" class="headerlink" title="3.2 线程池参数"></a>3.2 线程池参数</h3><ol><li>corePoolSize: 线程池中的常驻核心线程数，即使空闲也不归还。</li><li>maximumPoolSize: 线程池能够容纳同时执行的最大线程数，空闲了会归还给操作系统。</li><li>keepAliveTime: 多余的空闲线程存活时间。</li><li>unit: keepAliveTime的单位。</li><li>workQueue: 任务队列，被提交但尚未被执行的任务，一般使用阻塞队列。</li><li>threadFactory: 表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认即可。</li><li>handler: 拒绝策略，表示当队列满了并且工作线程大于等于线程的最大线程数时如何来拒绝请求执行的runnable策略。</li></ol><h3 id="3-3-线程池底层工作原理"><a href="#3-3-线程池底层工作原理" class="headerlink" title="3.3 线程池底层工作原理"></a>3.3 线程池底层工作原理</h3><ul><li><p>在创建了线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做如下判断</p><ul><li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行任务</li><li>如果正在运行的线程大于等于corePoolSize，那么将这个任务放入队列</li><li>如果这时队列满了且正在运行的线程数量小于maximumPoolSize，那么要创建非核心线程立刻运行这个任务</li><li>如果队列满了且正在运行的线程数大于等于maximumPoolSize，那么线程池会启动拒绝策略</li></ul></li><li><p>当一个线程完成任务时，他会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做超过keepAliveTime时，线程会判断：</p><ul><li>如果当线程数大于corePoolSize，那么这个线程就被停掉</li><li>线程池的所有任务完成后最终会收缩到corePoreSize</li></ul></li></ul><h3 id="3-4-拒绝策略"><a href="#3-4-拒绝策略" class="headerlink" title="3.4 拒绝策略"></a>3.4 拒绝策略</h3><p>定义：等待队列和max线程数都满了，那么就需要启用拒绝策略处理这个问题。</p><ul><li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常</li><li>CallerRunsPolicy：既不会抛弃任务，也不会抛出异常，而是把某些任务回退给调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li><li>自定义Policy：实现 <code>RejectedExecutionHandler</code> 接口</li></ul><h3 id="3-5-自定义线程池"><a href="#3-5-自定义线程池" class="headerlink" title="3.5 自定义线程池"></a>3.5 自定义线程池</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">3</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadFactory</span>(<span class="hljs-string">&quot;myPool&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fi</span> <span class="hljs-operator">=</span> i;<br>      pool.execute(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + fi);<br>      &#125;);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    pool.shutdown();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br><br>  MyThreadFactory(String prefix) &#123;<br>    <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>    group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>    Thread.currentThread().getThreadGroup();<br>    namePrefix = prefix + <span class="hljs-string">&quot;-&quot;</span> +<br>      poolNumber.getAndIncrement() +<br>      <span class="hljs-string">&quot;-thread-&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r,<br>                          namePrefix + threadNumber.getAndIncrement(),<br>                          <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (t.isDaemon())<br>      t.setDaemon(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>      t.setPriority(Thread.NORM_PRIORITY);<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ThreadPoolTaskExecutor"><a href="#ThreadPoolTaskExecutor" class="headerlink" title="ThreadPoolTaskExecutor"></a>ThreadPoolTaskExecutor</h4><blockquote><p>Spring 为我们提供的线程池类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;taskExector&quot;)</span><br><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">taskExector</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<span class="hljs-comment">//获取到服务器的cpu内核</span><br>  executor.setCorePoolSize(<span class="hljs-number">5</span>);<span class="hljs-comment">//核心池大小</span><br>  executor.setMaxPoolSize(<span class="hljs-number">100</span>);<span class="hljs-comment">//最大线程数</span><br>  executor.setQueueCapacity(<span class="hljs-number">1000</span>);<span class="hljs-comment">//队列程度</span><br>  executor.setKeepAliveSeconds(<span class="hljs-number">1000</span>);<span class="hljs-comment">//线程空闲时间</span><br>  executor.setThreadNamePrefix(<span class="hljs-string">&quot;task-asyn&quot;</span>);//线程前缀名称<br>  executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="hljs-comment">//配置拒绝策略</span><br>  <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name=&quot;taskExecutor&quot;)</span><br>ThreadPoolTaskExecutor taskExecutor;<br></code></pre></td></tr></table></figure><h3 id="3-6-如何合理配置线程池"><a href="#3-6-如何合理配置线程池" class="headerlink" title="3.6 如何合理配置线程池"></a>3.6 如何合理配置线程池</h3><p><img src="https://img-blog.csdnimg.cn/20210116163921272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Cpu密集型(Cpu一直运行)：Cpu核数+1个线程的线程池</li><li>IO密集型(需要不断取数据)：<ul><li>IO密集型并不是一直在执行任务，配置尽可能多的线程，如Cpu核数 * 2</li><li>Cpu核数 &#x2F; (1 - 阻塞系数(0.8~0.9))例如8核Cpu：8 &#x2F; (1 - 0.9) &#x3D; 80个线程数</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础</title>
    <link href="/pumpkin/2022/05/20/Java/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/pumpkin/2022/05/20/Java/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h2><ol><li>类初始化：静态方法 -&gt; 静态代码块，先初始化父类再初始化子类</li><li>实例初始化 ：顺序: 非静态实例变量、非静态代码块、构造器代码</li><li>子类覆写了父类的方法，初始化时只会执行子类的方法，若父类方法没被覆写，则执行父类方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> param();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> paramParent();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> staticParam();<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类静态代码块&quot;</span>);<br>    &#125;<br><br>    Parent()&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类构造方法&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">param</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类实例变量1&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">paramParent</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类实例变量2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">staticParam</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类静态实例变量&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> param();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> staticParam();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类静态代码块&quot;</span>);<br>    &#125;<br><br>    Child()&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类构造方法&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">param</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类实例变量&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">staticParam</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类静态实例变量&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p>父类静态实例变量</p><p>父类静态代码块</p><p>子类静态实例变量</p><p>子类静态代码块</p><p>子类实例变量</p><p>父类实例变量2</p><p>父类代码块</p><p>父类构造方法</p><p>子类实例变量</p><p>子类代码块</p><p>子类构造方法</p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>静态变量作用在类层面，所有实例都会共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticVariableDemo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num;<br><br>    &#123;<br>        num++;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">plus</span><span class="hljs-params">()</span>&#123;<br>        num++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StaticVariableDemo</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticVariableDemo</span>();<br>        <span class="hljs-type">StaticVariableDemo</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticVariableDemo</span>();<br>        d1.plus();<br>        d2.plus();<br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><table><thead><tr><th>静态内部类</th><th>非静态内部类</th></tr></thead><tbody><tr><td>可以有静态成员(方法，属性)</td><td>不能有静态成员(方法，属性)</td></tr><tr><td>实例化<br />OutClassTest.InnerStaticClass inner &#x3D; new OutClassTest.InnerStaticClass();</td><td>实例化<br />OutClassTest oc1 &#x3D; new OutClassTest();<br />OutClassTest.InnerClass inner &#x3D; oc1.new InnerClass();</td></tr><tr><td>调用方法或静态变量，通过类名直接调用<br />OutClassTest.InnerStaticClass.staticValue<br />OutClassTest.InnerStaticClass.method()</td><td>实例化出来之后正常调用<br />inner.method()</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String中的intern()方法</p><p>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用，否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><p>例题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot;World&quot;</span>).toString();<br>System.out.println(str1 == str1.intern());      <span class="hljs-comment">// true</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ja&quot;</span>).append(<span class="hljs-string">&quot;va&quot;</span>).toString();<br>System.out.println(str2 == str2.intern());      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>解释：有一个JDK自带的初始化的字符串”java”在加载sun.misc.Version这个类的时候进入了常量池</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>基本数据类型：传递值</li><li>引用数据类型：传地址</li></ul><p>String、包装类等属于引用数据类型，同时是<strong>不可变对象</strong></p><blockquote><p>《Effective Java》<br>不可变对象(Immutable Object)：对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。<br>由于ImmutableObject不提供任何setter方法，并且成员变量value是基本数据类型，getter方法返回的是value的拷贝，所以一旦ImmutableObject实例被创建后，该实例的状态无法再进行更改，因此该类具备不可变性。</p></blockquote><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>对象的序列化主要有两种用途：</p><ol><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中</li><li>在网络上传送对象的字节序列</li></ol><p>serialVersionUID作用：序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。</p><p>有两种生成方式：</p><ol><li>默认的1L，比如：private static final long serialVersionUID &#x3D; 1L</li><li>根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> xxxxL;<br></code></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意方法和属性。</p></blockquote><p>获取 Class 对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 User 对象的Class</span><br>Class&lt;User&gt; clazz = User.class;<br>Class&lt;User&gt; clazz = user.getClass();<br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.demo.entity.User&quot;</span>);<br>Class&lt;?&gt; clazz = classLoader.loadClass(<span class="hljs-string">&quot;com.demo.entity.User&quot;</span>);<br></code></pre></td></tr></table></figure><p>利用反射创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User 需要有无参构造</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><span class="hljs-comment">// 利用 User 的有参构造创建</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p>利用反射操作属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据属性名获取属性值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldValue</span><span class="hljs-params">(String fieldName, Object object)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> object.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> field.get(object);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.warn(<span class="hljs-string">&quot;反射获取数据异常&quot;</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据属性名设置属性值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(String fieldName, Object object, Object value)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class&lt;?&gt; c = object.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(fieldName);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(object, value);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.warn(<span class="hljs-string">&quot;反射设置数据异常&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>反射中Class.forName和ClassLoader.loadClass的区别</strong></p><ol><li><p>class.forName除了将类的class文件加载到jvm中之外，还会对类进行解释，执行类中的static块，还会执行给静态变量赋值的静态方法</p></li><li><p>classLoader只干一件事情，就是将class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p></li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>可以通过注解来获取相关属性，通过这些属性再配合反射实现相应业务。</p><p>案例：通过反射获取全类名，再通过全类名实例化对应的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Channel&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 连接接口 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">build</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloudConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Connect to cloud&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Connect to database&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Channel(&quot;com.demo.basic.annotation.DatabaseConnection&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Connection conn;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getAnnotation(Channel.class);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过反射获取到Connection对象实例</span><br>            conn = (Connection) Class.forName(channel.value()).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-comment">// 执行build方法，实际上执行的是Connection接口的实现类</span><br>        <span class="hljs-keyword">if</span> (conn.build())&#123;<br>            System.out.println(<span class="hljs-string">&quot;消息发送:&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>        msg.send(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream-Api"><a href="#Stream-Api" class="headerlink" title="Stream Api"></a>Stream Api</h2><p>Stream 是数据渠道，用于操作数据源所生成的元素序列。</p><ol><li>Stream 不存储元素</li><li>Stream 不改变源对象，他们会返回一个持有结果的新的 Stream</li><li>Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候执行</li></ol><p>Stream 操作步骤：创建流 -&gt; 中间操作 -&gt; 终止操作</p><p><strong>Stream Create</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.集合类</span><br>Collection.stream();<br><span class="hljs-comment">// 2.数组</span><br>Arrays.stream(T[]);<br><span class="hljs-comment">// 3.of</span><br>Stream.of(T... values);<br><span class="hljs-comment">// 4.创建无限流</span><br><span class="hljs-comment">// 4.1.迭代，案例：获取前10个偶数</span><br>Stream.iterate(<span class="hljs-keyword">final</span> T seed, <span class="hljs-keyword">final</span> UnaryOperator&lt;T&gt; f);<br>Stream.iterate(<span class="hljs-number">0</span>, x -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br><span class="hljs-comment">// 4.2.生成，案例：获取前10个随机数</span><br>Stream.genrate(Supplier&lt;T&gt; s);<br>Stream.generate(Math::random).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><strong>Stream Middle Operation</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 筛选和切片</span><br><span class="hljs-comment"> * - filter     接收lambda，从流冲排除某些元素</span><br><span class="hljs-comment"> * - limit      截断流，使其元素不超过给定数量</span><br><span class="hljs-comment"> * - skip(n)    跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit互补</span><br><span class="hljs-comment"> * - distinct   筛选，通过流所生成元素的hashCode()和equals()去除重复元素</span><br><span class="hljs-comment"> */</span><br>emps.stream().filter(e -&gt; e.getSalary() &gt;= <span class="hljs-number">100</span>).limit(<span class="hljs-number">3</span>).forEach(System.out::println);<br>emps.stream().filter(e -&gt; e.getSalary() &gt;= <span class="hljs-number">100</span>).skip(<span class="hljs-number">1</span>).forEach(System.out::println);<br>emps.stream().filter(e -&gt; e.getSalary() &gt;= <span class="hljs-number">100</span>).distinct().forEach(System.out::println);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 映射</span><br><span class="hljs-comment"> * map      接收lambda，将元素转换成其它形式或提取信息。接收另一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素。</span><br><span class="hljs-comment"> * flatMap  接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流，类似于list.allAll()</span><br><span class="hljs-comment"> * mapToDouble</span><br><span class="hljs-comment"> * mapToInt</span><br><span class="hljs-comment"> * mapToLong</span><br><span class="hljs-comment"> */</span><br>list.stream().map(String::toUpperCase).forEach(System.out::println);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 排序</span><br><span class="hljs-comment"> * sorted()                 自然排序(Comparable)</span><br><span class="hljs-comment"> * sorted(Comparator com)   定制排序(Comparator)</span><br><span class="hljs-comment"> */</span><br>list.stream().sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><strong>Stream Termination</strong></p><p>匹配和查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否匹配所有元素 allMatch</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> emps.stream().allMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));<br><br><span class="hljs-comment">// 至少匹配一个元素 anyMatch</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> emps.stream().anyMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));<br><br><span class="hljs-comment">// 检查是否没有匹配所有元素 noneMatch</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> emps.stream().noneMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));<br><br><span class="hljs-comment">// 倒排后返回第一个元素 findFirst</span><br>Optional&lt;Employee&gt; op = emps.stream().sorted(Comparator.comparingDouble(Employee::getSalary).reversed()).findFirst();<br>System.out.println(op.get());<br><br><span class="hljs-comment">// 返回任意元素的值 findAny</span><br>Optional&lt;Employee&gt; op1 = emps.stream().filter(e -&gt; e.getStatus().equals(Employee.Status.FREE)).findAny();<br>System.out.println(op1.get());<br><br><span class="hljs-comment">// 返回元素总个数 count</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> emps.stream().count();<br><br><span class="hljs-comment">// 返回流中最大值 max</span><br>Optional&lt;Employee&gt; max = emps.stream().max(Comparator.comparingDouble(Employee::getSalary));<br>System.out.println(max.get());<br><br><span class="hljs-comment">// 返回流中最小值 min</span><br>Optional&lt;Double&gt; min = emps.stream().map(Employee::getSalary).min(Double::compare);<br>System.out.println(min.get());<br></code></pre></td></tr></table></figure><p>归约：可以将流中的元素反复结合起来，得到一个值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">reduce(T identity, BinaryOperator);<br>reduce(BinaryOperator);<br><span class="hljs-comment">// 案例：求和</span><br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p>收集：将流转换为其它形式，接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集为List</span><br>List&lt;String&gt; list = emps.stream().map(Employee::getName).collect(Collectors.toList());<br><span class="hljs-comment">// 分组</span><br>Map&lt;Employee.Status, List&lt;Employee&gt;&gt; map = emps.stream()<br>    .collect(Collectors.groupingBy(Employee::getStatus));<br><span class="hljs-comment">// 多级分组</span><br>Map&lt;Employee.Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream()<br>    .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(e -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">35</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;青年&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;老年&quot;</span>;<br>        &#125;<br>    &#125;)));<br><span class="hljs-comment">// 分区</span><br>Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream()<br>    .collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; <span class="hljs-number">8000</span>));<br><span class="hljs-comment">// 统计</span><br><span class="hljs-type">DoubleSummaryStatistics</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> emps.stream()<br>    .collect(Collectors.summarizingDouble(Employee::getSalary));<br>System.out.println(summary.getSum());<br>System.out.println(summary.getAverage());<br>System.out.println(summary.getMax());<br><span class="hljs-comment">// 拼接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> emps.stream().map(Employee::getName).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><ol><li><p>class loading</p></li><li><p>class linking (verification preparation resolution)</p></li><li><p>class initializing：静态变量赋值，执行静态语句块</p></li><li><p>申请内存对象</p></li><li><p>成员变量赋值</p></li><li><p>调用构造方法</p><ol><li>成员变量顺序赋初始值</li><li>执行构造方法语句</li></ol></li></ol><h3 id="对象在内存中的存储布局"><a href="#对象在内存中的存储布局" class="headerlink" title="对象在内存中的存储布局"></a>对象在内存中的存储布局</h3><p>一个Object对象占16个字节</p><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><ol><li><p>对象头 markdown 8</p></li><li><p>ClassPoniter指针：开启-XX:+UseCompressedClassPoiners 为4字节，不开启为8字节</p></li><li><p>实例数据</p><p>引用类型：开启-XX:+UseCompressedOops为4字节 不开启为8字节</p></li><li><p>Padding对齐：8的倍数</p></li></ol><h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><ol><li>对象头 markdown 8</li><li>ClassPoniter指针：开启-XX:+UseCompressedClassPoiners 为4字节，不开启为8字节</li><li>数组长度：4字节</li><li>数组数据</li><li>Padding对齐：8的倍数</li></ol><h3 id="对象头信息"><a href="#对象头信息" class="headerlink" title="对象头信息"></a>对象头信息</h3><p>对象头信息包括：对象的HashCode，锁标志位、GC标记（分代的年龄）等</p><p>markword 64位</p><p><img src="https://img-blog.csdnimg.cn/2021011712102443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="对象定位"><a href="#对象定位" class="headerlink" title="对象定位"></a>对象定位</h3><ol><li>句柄池：间接指针，一个指向对象，另一个指向了.class</li><li>直接指针（HotSpot）：直接指向对象，对象再指向.class</li></ol><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>首先new一个对象的时候尝试往栈上分配，如可以分配下，就分配到栈上，栈一弹出对象就没了。</p><p>如果对象过大，栈分配不下，直接分配到堆内存（老年代）。</p><p>如果对象不大，先进行线程本地分配，分配不下找伊甸区，然后进行GC的过程，年龄到了进入老年代。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java JVM</title>
    <link href="/pumpkin/2022/05/20/Java/JavaJVM/"/>
    <url>/pumpkin/2022/05/20/Java/JavaJVM/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="Java从编码到执行"><a href="#Java从编码到执行" class="headerlink" title="Java从编码到执行"></a>Java从编码到执行</h3><p><img src="https://img-blog.csdnimg.cn/20210111203500781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>解释器：bytecode intepreter</p><p>JIT：Just In-Time compiler</p><p>混合使用解释器 + 热点代码编译</p><p>起始阶段采用解释执行</p><p>热点代码检测</p><ul><li><p>多次被调用的方法（方法计数器：监测方法执行频率）</p></li><li><p>多次被调用的循环（循环计数器：监测循环执行频率）</p></li><li><p>进行编译</p></li><li><p>-Xmixed 默认为混合模式 开始解释执行，启动速度较快，对热点代码实行检测和编译</p></li><li><p>-Xint 使用编译模式，启动很快，执行稍慢</p></li><li><p>-Xcomp 使用纯编译模式，执行很快，启动很慢</p></li></ul><h3 id="Class类文件解释"><a href="#Class类文件解释" class="headerlink" title="Class类文件解释"></a>Class类文件解释</h3><p><img src="https://img-blog.csdnimg.cn/20210111220329956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Class生命周期"><a href="#Class生命周期" class="headerlink" title="Class生命周期"></a>Class生命周期</h3><p><img src="https://img-blog.csdnimg.cn/20210111220751109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p><strong>类加载流程图：</strong><br><img src="https://img-blog.csdnimg.cn/20200131191909464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>类加载器示意图：</strong><br><img src="https://img-blog.csdnimg.cn/20210111220915818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>ClassLoader</strong>：负责加载class文件（class文件在文件开头有特定文件标识）</p><p><strong>各个类加载器的作用</strong></p><p>BootStrapClassLoader 引导类加载器：加载JVM自身需要的类，使用C++实现，负责加载<code>%JAVA_HOME%/jre/lib.jar</code>核心类库。</p><p>ExtensionClassLoader 扩展类加载器：负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext目录下的类。</p><p>AppClassLoader 系统类加载器：负责加载系统类路径<code>java -classpath</code>或<code>-D java.class.path</code> 指定路径下的类库。</p><p>CustomClassLoader 自定义类加载器：继承ClassLoader重写findClass方法</p><p><strong>双亲委派</strong>：JVM收到类加载请求，他会自底向上地去缓存中找这个类，找到了返回，没找到就把这个请求委派给父加载器（不是继承）去寻找，直到BootstrapClassLoader也没找到时，会自顶向下加载这个class，如果到最后还没加载成功，则会抛出异常 <code>ClassNotFoundException</code></p><p>作用：沙箱安全，不让自己定义的类去勿扰JDK出厂自带的类</p><p><img src="https://img-blog.csdnimg.cn/20210111223139570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><p><img src="https://img-blog.csdnimg.cn/20200131192106991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li><strong>程序计数器</strong>：存放指令位置，虚拟机的运行就是循环取PC中的指令</li><li><strong>栈</strong>：每个JVM都有自己私有的JVM栈，JVM栈用来存储栈帧</li><li><strong>本地方法栈</strong>：存放native方法的地方。</li><li><strong>堆</strong>：所有线程共享，存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</li><li><strong>方法区</strong>：存储class二进制文件、类信息、常量、静态变量、运行时常量池</li><li><strong>直接内存</strong>：JVM可以直接访问的内核空间的内存。</li></ol><p><strong>图示：线程的共享区和私有区</strong></p><p><img src="https://img-blog.csdnimg.cn/20210119205519997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈：每个JVM都有自己私有的JVM栈，JVM栈用来存储Frame</p><p>Frame：每个方法对应一个 Frame</p><p>Frame 存放：Local Variable Table, Operated Stack, Dynamic Linking, Return Address</p><p>Local Variable Table：byte、short、int、long、float、double、boolean、char、reference</p><p>Dynamic Linking：A方法调用B方法，这个过程就叫动态链接</p><p>Return Address：A方法调用B方法，B方法返回值的存放地址</p><p>案例：输出结果为8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将8压入操作数栈，再将8拿出来赋值给i</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 将8压入操作数栈，i加1，从操作数栈中弹出8赋值给i</span><br>i = i++;<br><span class="hljs-comment">// 输出最终结果 8</span><br>System.out.println(i);<br></code></pre></td></tr></table></figure><p><strong>栈上分配</strong> </p><p>逃逸分析：逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。 </p><p>标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。 </p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h3><p>Java 中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在 Java 栈中的）， 堆是被所有线程共享的，在 JVM 中只有一个堆。所有对象实例以及数组都要在堆上分配内 存，单随着 JIT 发展，栈上分配，标量替换优化技术，在堆上分配变得不那么到绝对，只能在 server 模式下才能启用逃逸分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 左边存放在栈中，右边存放在堆中</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><h3 id="JVM-内存分代模型"><a href="#JVM-内存分代模型" class="headerlink" title="JVM 内存分代模型"></a>JVM 内存分代模型</h3><blockquote><p>除了 Epsilon ZGC Shenandoah 之外的GC都是使用逻辑分代模型</p><p>G1是逻辑分代，物理不分代</p><p>除上述 GC 模型之外不仅是逻辑分代，而且是物理分代</p></blockquote><p>新生代 &#x3D; Eden区 + 2 个 Suvivor区</p><ol><li>YGC 回收之后，大多数对象被回收，活着的进入S0</li><li>再次 YGC ，活着的对象 Eden + S0 -&gt; S1</li><li>再次 YGC， Eden + S1 -&gt; S0</li><li>年龄足够进入老年代</li><li>分配担保：Suvivor区装不下直接进入老年代</li></ol><p>老年代：</p><ol><li>老年代满了就Full GC</li></ol><p>永久代（1.7）&#x2F; 元空间（1.8）</p><ol><li>永久代 元空间 - Class</li><li>永久代必须指定大小限制，元空间可以设置，也可以不设置，上限取决于物理内存</li><li>字符串常量 1.7 - 永久代，1.8 - 堆</li><li>永久代和元空间都是方法区的实现</li></ol><p>图示</p><p><img src="https://img-blog.csdnimg.cn/20200131193503949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="实例化对象分配"><a href="#实例化对象分配" class="headerlink" title="实例化对象分配"></a>实例化对象分配</h3><ol><li><p>栈上分配</p><p>线程私有小对象、无逃逸、支持标量替换</p></li><li><p>线程本地分配 TLAB （Thread Local Alllocation Buffer）</p><p>默认占用Eden的1%、多线程的时候不用竞争Eden就可以申请空间，提升效率、小对象</p></li><li><p>老年代：大对象</p></li></ol><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="GC概述"><a href="#GC概述" class="headerlink" title="GC概述"></a>GC概述</h3><p>GC是什么（分代收集算法）</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不动元空间</li></ul><p>普通GC(Minor GC)：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大部分Java对象存活率不高，所以Minor GC非常频繁，一般回收速度也比较快。</p><p>全局GC(Major GC &#x2F; Full GC)：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC，Major GC的速度一般要比Minor GC慢10倍以上。</p><p><strong>Card Table</strong></p><p>由于做 YGC 时，需要扫描整个 OLD 区，效率非常低，所以 JVM 设计了 Card Table，如果一个 OLD 区的 Card Table 中有对象指向 Y 区，就将它设为 Dirty，下次扫描时，只需要扫描 Ditry Card。在结构上，Card Table 用 Bit Map 实现。</p><p><strong>CSet（Collection Set）</strong></p><p>一组可以被回收的集合，在CSet中存活的数据会在GC的过程中被移动到另一个可用分区，CSet中的分区可以来自Eden、Survivor、Old区，CSet会占用不到整个堆空间1%的大小。简单来说，G1中需要被回收的Card的集合。</p><p><strong>RSet（Remembered Set）</strong></p><p>记录了其它 Region 中的对象到本 Region 的引用</p><p>使得垃圾回收器不需要扫描整个堆栈来找到谁引用了当前分区中的对象，只需要扫描 RSet 即可</p><p>由于RSet的存在，那么每次给对象赋值引用的时候，就得做一些额外的操作：在RSet中做一些额外的记录，在GC中被称为写屏障（这个写屏障 不等于内存屏障）</p><h3 id="如何定位垃圾"><a href="#如何定位垃圾" class="headerlink" title="如何定位垃圾"></a>如何定位垃圾</h3><p><strong>引用计数法</strong></p><p>没有被引用的内存空间就是垃圾，需要被收集</p><p>缺点：计数器本身有消耗，较难处理循环引用</p><p><strong>根可达性分析算法</strong></p><p>通过一系列的名为”GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。</p><p>Java 可以做GC Root的对象：局部变量表、静态变量引用的对象、常量池引用的对象、Native方法引用的对象。</p><h3 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h3><ol><li><p>复制算法（Copying）：没有碎片，浪费空间</p><p>YGC用的是复制算法，复制算法的基本思想是将内存分为两块，每次只用其中一块，当一块内存用完，就将还活着的对象复制到另一块上面，复制算法不会产生内存碎片。</p><p>原理：从根集合（GC Root）开始，通过Tracing从From中找到存活对象，拷贝到To中。From和To交换身份，下次内存分配从To开始</p><p>缺点：浪费了一半内存</p></li><li><p>标记清除（Mark-Sweep）：位置不连续，产生碎片，效率偏低（两遍扫描）</p><p>老年代一般由标记清除和标记整理混合实现</p><p>原理：算法分成标记和清除两个阶段。在标记阶段，collector从根对象开始进行遍历，对从根对象可以访问到的对象都打上一个标识，将其记录为可达对象。在清除阶段，collector对堆内存从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象，则就将其回收。</p><p>解释：程序运行期间，可用内存将被耗尽的时候,GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象。</p><p>缺点：两次扫描，耗时严重，会产生内存碎片（清理出来的内存是不连续的）</p></li><li><p>标记清除压缩（Mark-Compact）：没有碎片，效率偏低（两遍扫描，指针需要调整）</p><p>第一步：标记清除<br><img src="https://img-blog.csdnimg.cn/20200117210457686.png" alt="在这里插入图片描述"><br>第二步：压缩，再次扫描，并往一端滑动存活对象<br><img src="https://img-blog.csdnimg.cn/20200117210521309.png" alt="在这里插入图片描述"></p></li></ol><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li><p>串行回收：单线程，会暂停所有的用户线程，Serial + Serial Old</p></li><li><p>并行回收：多线程，会暂停所有的用户线程，Parallel Scavenge + Parallel Old（JDK8默认）</p></li><li><p>并发标记清除：用户线程和垃圾收集线程同时执行（并行或交替），ParNew + CMS</p><ul><li><p>CMS四个阶段：初始标记，并发标记，重新标记，并发清除</p></li><li><p>CSM的问题：会产生碎片，有浮动垃圾，当老年代碎片过多，换Serial Old上场</p></li><li><p>CMS问题解决方案之一：降低触发CMS的阈值，如果频繁发生SerialOld卡顿，应该调小阈值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:CMSInitiatingOccupancyFraction 70% # 内存空间降低到70%再进行回收，默认是68%<br></code></pre></td></tr></table></figure></li></ul></li><li><p>G1：将堆内存分割成不同的区域并发的对其进行垃圾回收，只在逻辑上分年轻代老年代</p><p>G1可以在大多数情况下实现指定的GC暂停时间，同时还能保持较高的吞吐量。</p><p>G1可以动态地调整新老年代的比例，调整的依据是 YGC 的暂停时间。比如指定的暂定时间是20ms，此时10个 region 中有6个Y区，但回收时间是30ms，那么G1会将6个Y区减少至5个或4个Y区直到暂定时间小于20ms为止。</p><p>G1在对象太多的时候也会产生Full GC，如果产生Full GC，我们应该做：</p><ol><li><p>扩内存</p></li><li><p>提高 CPU 性能</p></li><li><p>降低 MixedGC 触发的阈值，让MixedGC提早发生（默认45%)</p><p>MixedGC（类似CMS）：初始标记STW，并发标记，最终标记STW，筛选回收STW（并行）</p></li></ol></li></ul><p><img src="https://img-blog.csdnimg.cn/2021011714275194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="垃圾回收器算法"><a href="#垃圾回收器算法" class="headerlink" title="垃圾回收器算法"></a>垃圾回收器算法</h3><p><strong>垃圾回收器使用的算法</strong></p><p>CMS：三色标记 + Incremental Update</p><p>G1：三色标记 + SATB（Snapshot at the begining）</p><p>ZGC：Colored Pointers（颜色指针）</p><p><strong>三色标记算法</strong></p><p>三色标记把对象在逻辑上分成三种颜色</p><p>白：未被标记的对象</p><p>灰：自身被标记，成员变量未被标记</p><p>黑：自身和成员变量均已标记完成</p><p>漏标：本来是 live object，但是由于没有遍历到，被当成 garbage 回收掉了。在并发标记的过程中，黑色指向了白色，如果不对黑色重新扫描，则会把白色对象当做没有新引用指向从而回收掉。</p><p>如果解决漏标：Incremental Update、SATB</p><p>Incremental Update（增量更新）：当一个白色对象被一个黑色对象引用，将黑色重启标记为灰色，让 Controller 重新扫描</p><p>SATB（Snapshot at the begining）：在起始的时候做一个快照，当灰色-&gt;白色引用消失时，要把这个引用推到GC的堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆区查找指向白色的引用，效率比较高。</p><p><img src="https://img-blog.csdnimg.cn/20210214141554379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>强引用：OOM也不回收</li><li>软引用：内存不足时回收</li><li>弱引用：只要执行GC就被回收</li><li>虚引用：跟没引用一样，可以用来管理堆外内存（直接内存），当对象被回收时，通过Queue可以检测到，然后清理堆外内存。堆外内存如何回收 – Unsafe.freeMemory(address)</li></ul><h3 id="GC-常用参数"><a href="#GC-常用参数" class="headerlink" title="GC 常用参数"></a>GC 常用参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">年轻代 最小堆 最大堆 栈空间</span><br>-Xmn -Xms -Xmx -Xss<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用TLAB，默认打开</span><br>-XX:+UseTLAB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印TLAB的使用情况</span><br>-XX:+PrintTLAB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置TLAB大小</span><br>-XX:TLABSize<br><span class="hljs-meta prompt_"># </span><span class="language-bash">禁用 System.gc()，System.gc()是Full GC</span><br>-XX:+DisableExplictGC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印GC</span><br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintHeapAtGC<br>-XX:+PrintGCTimeStamps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印应用程序时间</span><br>-XX:+PrintGCApplicationConcurrentTime<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打印暂停时长</span><br>-XX:+PrintGCApplicationStoppedTime<br><span class="hljs-meta prompt_"># </span><span class="language-bash">记录回收了多少种不同引用类型的引用</span><br>-XX:+PrintReferenceGC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可在程序运行时，打印虚拟机接受到的命令行显示参数</span><br>-XX:+PrintVMOptions<br><span class="hljs-meta prompt_"># </span><span class="language-bash">GC的升代年龄</span><br>-XX:MaxTenuringThreshold<br><span class="hljs-meta prompt_"># </span><span class="language-bash">锁自旋次数</span><br>-XX:PreBlockSpin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">热点代码检测参数，执行多少次会变成热点代码进行本地化的编译</span><br>-XX:ComplieThreshold<br></code></pre></td></tr></table></figure><h3 id="Parallel-常用参数"><a href="#Parallel-常用参数" class="headerlink" title="Parallel 常用参数"></a>Parallel 常用参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Survivor的比例</span><br>-XX:SurvivorRatio<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多大的大对象会被直接分配到Old区</span><br>-XX:PreTenureSizeThreshold<br><span class="hljs-meta prompt_"># </span><span class="language-bash">并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同</span><br>-XX:+ParallelGCThreads<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自动选择各区大小比例</span><br>-XX:+UseAdaptiveSizePolicy<br></code></pre></td></tr></table></figure><h3 id="CMS-常用参数"><a href="#CMS-常用参数" class="headerlink" title="CMS 常用参数"></a>CMS 常用参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用CMS</span><br>-XX:+UseConcMarkSweepGC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">CMS线程数量</span><br>-XX:ParallelCMSThreads<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用多少比例的老年代后开始CMS收集，默认是68%</span><br>-XX:CMSInitiatingOccupancyFraction<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在FGC时进行压缩(标记整理)</span><br>-XX:+UseCMSCompactAtFullCollection<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多少次FGC后进行压缩</span><br>-XX:CMSFullGCsBeforeCompaction<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停顿时间</span><br>-XX:MaxGCPauseMillis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">回收永久代</span><br>-XX:+CMSClassUnloadingEnabled<br><span class="hljs-meta prompt_"># </span><span class="language-bash">达到什么比例时进行Perm回收</span><br>-XX:CMSInitiatingPermOccupancyFraction<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置GC时间占用程序运行时间的百分比</span><br>GCTimeRatio<br></code></pre></td></tr></table></figure><h3 id="G1-常用参数"><a href="#G1-常用参数" class="headerlink" title="G1 常用参数"></a>G1 常用参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用G1</span><br>-XX:+UseG1GC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">建议最大停顿时间，GC会尝试调整Young区的块数来达到这个值</span><br>-XX:MaxGCPauseMillis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">分区大小，建议逐渐增大该值，1 2 4 8 16 32</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">随着size增加，垃圾存活的时间更长，GC间隔更长，但每次GC的时间也会更长</span><br>-XX:+G1HeapRegionSize<br><span class="hljs-meta prompt_"># </span><span class="language-bash">新生代最小比例，默认5%</span><br>G1NewSizePercent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">新生代最大比例，默认60%</span><br>G1MaxNewSizePercent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">GC时间建议比例，G1会根据这个值调整空间</span><br>GCTimeRatio<br><span class="hljs-meta prompt_"># </span><span class="language-bash">线程数量</span><br>ConcGCThreads<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动G1的堆空间占用比例</span><br>InitiatingHeapOccupancyPercent<br></code></pre></td></tr></table></figure><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>吞吐量：用户代码时间 &#x2F; ( 用户代码执行时间 + 垃圾回收时间 )</p><p>响应时间：STW（Stop The World）越短，响应时间越好</p><h3 id="JVM调优指令"><a href="#JVM调优指令" class="headerlink" title="JVM调优指令"></a>JVM调优指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有指令</span><br>java -X<br>java -XX:+PrintFlagsFinal -version<br><span class="hljs-meta prompt_"># </span><span class="language-bash">模糊查询指令</span><br>java -XX:+PrintFlagsFinal -version | grep Command <br></code></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms&lt;size&gt;        # 设置初始 Java 堆大小<br>-Xmx&lt;size&gt;        # 设置最大 Java 堆大小<br>-Xss&lt;size&gt;        # 设置 Java 线程堆栈大小<br>-XX:+PrintCommandLineFlags -version# 查看当前使用的垃圾回收器<br>-XX: MetaspaceSize=128m# 修改元空间大小<br>-XX: MaxTenuringThreshold=15# 修改老年代的大小<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo &lt;pid&gt;# 打印虚拟机详细信息<br>jstat -gc &lt;pid&gt; &lt;time&gt;# 打印gc信息，每&lt;time&gt;毫秒打印一次<br>jconsole# java控制面板<br></code></pre></td></tr></table></figure><h3 id="JVM调优场景"><a href="#JVM调优场景" class="headerlink" title="JVM调优场景"></a>JVM调优场景</h3><p><strong>系统CPU经常100%，如何调优</strong></p><p>CPU 100% 一定有线程在占用系统资源</p><ol><li>找出哪个进程的 CPU 高（top）</li><li>该进程的哪个线程 CPU 高（top - Hp [pid]）</li><li>导出该线程的堆栈（jstack）</li><li>查找哪个方法（栈帧）消耗时间 （jstack）</li><li>工作线程占比高 | 垃圾回收线程占比高</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Linux中哪个进程占资源</span><br>top<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只列出java的进程</span><br>jps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看这个&lt;pid&gt;的进程中哪个线程占资源</span><br>top -Hp &lt;pid&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看这个&lt;pid&gt;的线程堆栈</span><br>jstack &lt;pid&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出堆内存</span><br>jmap -heap &lt;pid&gt;<br></code></pre></td></tr></table></figure><p><strong>如何监控JVM</strong></p><p>jstat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">格式模板</span><br>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见用法</span><br>jstack &lt;pid&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">类加载统计</span><br>jstat -class 19570<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译统计</span><br>jstat -compiler 19570<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 观察信息</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">死锁</span><br>Found one java-level deadlock<br><span class="hljs-meta prompt_"># </span><span class="language-bash">锁时间过长</span><br>很多线程都在 waiting on &lt;0x00000000eda673f0&gt; 等待锁的释放<br>要找到 &lt;0x00000000eda673f0&gt; 这把锁被哪个线程持有<br>举例说明：一个程序有10个线程，第一个线程持有锁后死循环，其它线程全部WAITING，只有第一个线程是RUNNABLE<br></code></pre></td></tr></table></figure><p>jconsole jvisualvm</p><p><strong>执行GC之后内存占用依然很高</strong></p><p>使用jvisualvm打开GUI面板，监视 -&gt; 堆 Dump，截取一个内存快照。</p><p>检查 -&gt; 查找前20个最大的对象，可以检查到哪几个对象占用了大量的内存。</p><p><strong>JMX不建议在生产环境使用</strong></p><p>JMX一般是在测试环境使用，因为 JMX 会 patch 到 JVM 上而且占用了很大的性能。</p><p>如何在线上系统观察 可以使用 jmap 命令找到占用内存较大的类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jmap -histo 21853 | head -20<br></code></pre></td></tr></table></figure><p>但是对于内存特别大的系统，jmap执行期间会对进程产生很大影响，甚至卡顿</p><p>解决方案1：设定以下参数，OOM的时候会自动生成堆转储文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+HeapDumpOnOutOfMemoryError<br></code></pre></td></tr></table></figure><p>解决方案2：有服务器备份（高可用），停掉这台服务器对其它服务器不影响</p><h3 id="jconsole-远程连接"><a href="#jconsole-远程连接" class="headerlink" title="jconsole 远程连接"></a>jconsole 远程连接</h3><p>程序启动加入参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Djava.rmi.server.hostname=192.168.17.11<br>-Dcom.sun.management.jmxremote=11111<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false<br></code></pre></td></tr></table></figure><p>windows 打开 jconsole 远程连接 192.168.17.11:11111</p><h3 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h3><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC GCDemo<br></code></pre></td></tr></table></figure><p>日志说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[GC (Allocation Failure) [ParNew: 4544K-&gt;260K(6144K), 0.0012072 secs] 4544K-&gt;261K(19840K), 0.0012674 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br><br>ParNew：年轻代收集器<br><span class="hljs-meta prompt_">4544k-&gt;</span><span class="language-bash">260k: 收集前后对比</span><br>(6144k): 整个年轻代容量<br><span class="hljs-meta prompt_">4544K-&gt;</span><span class="language-bash">261K: 整个堆的情况</span><br>(19840K)：整个堆的大小<br></code></pre></td></tr></table></figure><h3 id="G1-日志"><a href="#G1-日志" class="headerlink" title="G1 日志"></a>G1 日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[GC pause (G1 Evacuation pause)(young)(initial-mark), 0.0015790 secs]<br><br>G1 Evacuation pause: 年轻代复制存活对象<br>initial-mark: 混合回收阶段，这里是YGC混合老年代回收<br></code></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>JVM一个线程的成本：1MB</p><p>线程多了调度成本就高了，造成了CPU的浪费</p><p>class被load到内存之后，class的二进制文件加载到内存里，与此同时生成了class类的对象，该对象指向了二进制文件。class对象存在metaspace</p><p>阿里多租户JVM：每租户单空间，Session based GC</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/pumpkin/2022/05/20/Java/JavaIO/"/>
    <url>/pumpkin/2022/05/20/Java/JavaIO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)<br>按数据流的流向不同分为：输入流，输出流<br>按流的角色的不同分为：节点流，处理流<br><img src="https://img-blog.csdnimg.cn/2020020116265641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>IO流体系<br><img src="https://img-blog.csdnimg.cn/20200201162728374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li>File类的实例化</li><li>流的实例化</li><li>读写的操作</li><li>资源的关闭</li></ol><h3 id="字符流操作文件-文本文件"><a href="#字符流操作文件-文本文件" class="headerlink" title="字符流操作文件(文本文件)"></a>字符流操作文件(文本文件)</h3><ol><li>读文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 实例化File类对象，指明要操作的文件</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/1.txt&quot;</span>);<br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 提供具体的流</span><br>        fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file);<br>        <span class="hljs-comment">// 每次读1024个字符</span><br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-comment">// read(char[] cbuf) 返回每次读入cbuf数组中字符的个数，如果到达文件末尾，返回-1</span><br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                System.out.print(cbuf[i]);<br>            &#125;<br>        &#125;<br>        fr.read(cbuf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>)<br>                fr.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>写文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/3.txt&quot;</span>);<br>    <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 参数2表示是否对原有文件追加</span><br>        fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(file, <span class="hljs-literal">false</span>);<br>        fw.write(<span class="hljs-string">&quot;Hello World 张三&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>)<br>                fw.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>先读后写 – 复制文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/3.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">dstFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/4.txt&quot;</span>);<br>    <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(srcFile);<br>        fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(dstFile, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>            fw.write(cbuf, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fr != <span class="hljs-literal">null</span>)<br>                fr.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fw != <span class="hljs-literal">null</span>)<br>                fw.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字节流操作文件-图片、视频等"><a href="#字节流操作文件-图片、视频等" class="headerlink" title="字节流操作文件(图片、视频等)"></a>字节流操作文件(图片、视频等)</h3><p>复制图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/img/1.jpg&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">dstFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/img/2.jpg&quot;</span>);<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile);<br>        fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dstFile);<br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = fis.read(buf)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(buf, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fis != <span class="hljs-literal">null</span>)<br>                fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>)<br>                fos.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓冲流的使用"><a href="#缓冲流的使用" class="headerlink" title="缓冲流的使用"></a>缓冲流的使用</h3><p>作用：提升流的读取、写入速度。<br>复制图片文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyImgFile</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/img/1.jpg&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">dstFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/img/2.jpg&quot;</span>);<br>    <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建节点流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFile);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dstFile);<br>        <span class="hljs-comment">// 创建缓冲流</span><br>        bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis);<br>        bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos);<br>        <span class="hljs-comment">// 读取写入</span><br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = bis.read(buf)) != -<span class="hljs-number">1</span>)&#123;<br>            bos.write(buf, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 资源关闭，关闭外层流的同时，内层流也会自动关闭</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (bis != <span class="hljs-literal">null</span>)<br>                bis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (bos != <span class="hljs-literal">null</span>)<br>                bos.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复制文本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyTxtFile</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">srcFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/1.txt&quot;</span>);<br>    <span class="hljs-type">File</span> <span class="hljs-variable">dstFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/resources/file/5.txt&quot;</span>);<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(srcFile);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(dstFile);<br>        br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr);<br>        bw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw);<br>        <span class="hljs-type">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = br.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>            bw.write(cbuf, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>)<br>                br.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (bw != <span class="hljs-literal">null</span>)<br>                bw.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/pumpkin/2021/11/30/Tools/Git/"/>
    <url>/pumpkin/2021/11/30/Tools/Git/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-仓库操作"><a href="#Git-仓库操作" class="headerlink" title="Git 仓库操作"></a>Git 仓库操作</h2><p>命令帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote --help<br></code></pre></td></tr></table></figure><p>查看远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure><p>添加远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin https://gitee.com/KeithRong/demo.git<br></code></pre></td></tr></table></figure><p>删除远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote remove origin<br></code></pre></td></tr></table></figure><h2 id="Git-推送操作"><a href="#Git-推送操作" class="headerlink" title="Git 推送操作"></a>Git 推送操作</h2><p>命令帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch --help<br>git add --help<br>git commit --help<br>git push --help<br></code></pre></td></tr></table></figure><p>将本地分支推送关联远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u origin master<br></code></pre></td></tr></table></figure><h2 id="Git-分支操作"><a href="#Git-分支操作" class="headerlink" title="Git 分支操作"></a>Git 分支操作</h2><p>命令帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout --help<br>git merge --help<br>git rebase --help<br></code></pre></td></tr></table></figure><p>创建新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b [branch_name]<br></code></pre></td></tr></table></figure><p>删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete [branch_name]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
